# - Enable stage2 build.
# - Use host ghc-pkg to recache
# - Enable `iserv` to cross compile Haskell Template

--- ghc-9.12.1/hadrian/src/Rules/Program.hs	2024-12-16 00:59:46.000000000 +0530
+++ ghc-9.12.1.mod/hadrian/src/Rules/Program.hs	2025-01-08 14:17:07.763051325 +0530
@@ -102,7 +102,7 @@
   cross <- flag CrossCompiling
   -- For cross compiler, copy @stage0/bin/<pgm>@ to @stage1/bin/@.
   case (cross, stage) of
-    (True, s) | s > stage0InTree -> do
+    (True, s) | s > stage0InTree && s < Stage2 -> do
         srcDir <- buildRoot <&> (-/- (stageString stage0InTree -/- "bin"))
         copyFile (srcDir -/- takeFileName bin) bin
     _ -> buildBinary rs bin ctx

--- ghc-9.12.1/hadrian/src/Rules/BinaryDist.hs	2024-12-16 00:59:45.000000000 +0530
+++ ghc-9.12.1.mod/hadrian/src/Rules/BinaryDist.hs	2025-02-22 12:22:10.630203486 +0530
@@ -144,18 +144,18 @@
     phony "binary-dist-dir" $ do
         version        <- setting ProjectVersion
         targetPlatform <- setting TargetPlatformFull
-        distDir        <- Context.distDir (vanillaContext Stage1 rts)
+        distDir        <- Context.distDir (vanillaContext Stage2 rts)
 
-        let ghcBuildDir      = root -/- stageString Stage1
+        let ghcBuildDir      = root -/- stageString Stage2
             bindistFilesDir  = root -/- "bindist" -/- ghcVersionPretty
             ghcVersionPretty = "ghc-" ++ version ++ "-" ++ targetPlatform
             rtsIncludeDir    = distDir -/- "include"
 
         -- We 'need' all binaries and libraries
-        all_pkgs <- stagePackages Stage1
+        all_pkgs <- stagePackages Stage2
         (lib_targets, bin_targets) <- partitionEithers <$> mapM pkgTarget all_pkgs
         cross <- flag CrossCompiling
-        iserv_targets <- if cross then pure [] else iservBins
+        iserv_targets <- iservBins
 
         let lib_exe_targets = (lib_targets ++ (map (\(_, p) -> p) (bin_targets ++ iserv_targets)))
 
@@ -231,8 +231,8 @@
         --
         -- N.B. the ghc-pkg executable may be prefixed with a target triple
         -- (c.f. #20267).
-        ghcPkgName <- programName (vanillaContext Stage1 ghcPkg)
-        cmd_ (bindistFilesDir -/- "bin" -/- ghcPkgName) ["recache"]
+        stage1ghcPkgPath <- programPath =<< programContext Stage1 ghcPkg
+        cmd_ stage1ghcPkgPath ["recache"]
 
 
 
@@ -335,7 +335,7 @@
         copyFile (ghcRoot -/- "aclocal.m4") (ghcRoot -/- "distrib" -/- "aclocal.m4")
         copyDirectory (ghcRoot -/- "m4") (ghcRoot -/- "distrib")
         buildWithCmdOptions [] $
-            target (vanillaContext Stage1 ghc) (Autoreconf $ ghcRoot -/- "distrib") [] []
+            target (vanillaContext Stage2 ghc) (Autoreconf $ ghcRoot -/- "distrib") [] []
         -- We clean after ourselves, moving the configure script we generated in
         -- our bindist dir
         removeFile (ghcRoot -/- "distrib" -/- "aclocal.m4")
@@ -368,7 +368,7 @@
 generateBuildMk :: Action String
 generateBuildMk = do
   dynamicGhc <- askDynGhcPrograms
-  rtsWays <- unwords . map show . Set.toList <$> interpretInContext (vanillaContext Stage1 rts) getRtsWays
+  rtsWays <- unwords . map show . Set.toList <$> interpretInContext (vanillaContext Stage2 rts) getRtsWays
   return $ unlines [ "GhcRTSWays" =. rtsWays
                    , "DYNAMIC_GHC_PROGRAMS" =. yesNo dynamicGhc ]
 
@@ -408,9 +408,9 @@
 -- database. For programs, it returns the path to the compiled executable.
 pkgTarget :: Package -> Action (Either FilePath (Package, FilePath))
 pkgTarget pkg
-    | isLibrary pkg = Left <$> pkgConfFile (vanillaContext Stage1 pkg)
+    | isLibrary pkg = Left <$> pkgConfFile (vanillaContext Stage2 pkg)
     | otherwise     = do
-        path <- programPath =<< programContext Stage1 pkg
+        path <- programPath =<< programContext Stage2 pkg
         return (Right (pkg, path))
 
 useGhcPrefix :: Package -> Bool
@@ -428,12 +428,13 @@
     if  -- ghc also has the ghci script wrapper
         -- N.B. programName would add the crossPrefix therefore we must do the
         -- same here.
-      | pkg == ghc    -> pure $ map (prefix++) ["ghc", "ghci"]
-      | pkg == runGhc -> pure $ map (prefix++) ["runghc", "runhaskell"]
+      | pkg == ghc    -> pure ["ghc", "ghci"]
+      | pkg == runGhc -> pure ["runghc", "runhaskell"]
         -- These are the packages which we want to expose to the user and hence
         -- there are wrappers installed in the bindist.
-      | pkg `elem` [hpcBin, haddock, hp2ps, hsc2hs, ghc, ghcPkg]
-                      -> (:[]) <$> (programName =<< programContext Stage1 pkg)
+      | pkg `elem` [hpcBin, haddock, hp2ps, hsc2hs, ghc, ghcPkg] -> do
+                      name <- programName =<< programContext Stage2 pkg
+                      pure [if prefix `isPrefixOf` name then drop (length prefix) name else name]
       | otherwise     -> pure []
 
 wrapper :: FilePath -> Action String
@@ -487,9 +488,9 @@
 --   explicitly and 'need' the result of building them.
 iservBins :: Action [(Package, FilePath)]
 iservBins = do
-  rtsways <- interpretInContext (vanillaContext Stage1 ghc) getRtsWays
+  rtsways <- interpretInContext (vanillaContext Stage2 ghc) getRtsWays
   traverse (fmap (\p -> (iserv, p)) . programPath)
-      [ Context Stage1 iserv w Final
+      [ Context Stage2 iserv w Final
       | w <- [vanilla, profiling, dynamic]
       , w `elem` rtsways
       ]

--- ghc-9.12.1/hadrian/bindist/Makefile	2024-12-16 00:59:45.000000000 +0530
+++ ghc-9.12.1.mod/hadrian/bindist/Makefile	2025-01-18 02:46:21.665571888 +0530
@@ -253,7 +253,7 @@
 	@echo "Updating the package DB"
 	$(foreach p, $(PKG_CONFS),\
 		$(call patchpackageconf,$(shell echo $(notdir $p) | sed 's/-[0-9.]*-[0-9a-zA-Z]*\.conf//g'),$(shell echo "$p" | sed 's:\0xxx\0:   :g'),$(docdir),$(shell mk/relpath.sh "$(ActualLibsDir)" "$(docdir)"),$(shell echo $(notdir $p) | sed 's/.conf//g')))
-	'$(DESTDIR)$(ActualBinsDir)/$(CrossCompilePrefix)ghc-pkg' --global-package-db "$(DESTDIR)$(ActualLibsDir)/package.conf.d" recache
+	'$(HOST_GHC_PKG)' --global-package-db "$(DESTDIR)$(ActualLibsDir)/package.conf.d" recache
 
 .PHONY: install_mingw
 install_mingw:
